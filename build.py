# Build sim

import xml.etree.ElementTree as ET
import sys
import os
from collections import defaultdict

import numpy as np


if "SUMO_HOME" in os.environ:
    tools = os.path.join(os.environ["SUMO_HOME"], "tools")
    sys.path.append(tools)
else:
    sys.exit("please declare environment variable 'SUMO_HOME'")

from .network import Node, Edge, Net, Crossing

from sumolib.xml import parse_fast_structured
from sumolib.miscutils import parseTime


# data from https://sumo.dlr.de/docs/Vehicle_Type_Parameter_Defaults.html sauf vitesse
base_routes_xml = """<?xml version="1.0" encoding="UTF-8"?>

<!-- generated by Eclipse SUMO netedit Version v1_13_0+0805-082359713bb -->

<routes xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="http://sumo.dlr.de/xsd/routes_file.xsd">
    <!-- VTypes -->
    <!-- <vType id="myESped" length="1.10" minGap="1.50" maxSpeed="12.50" speedFactor="normc(1.00,0.30,0.20,2.00)" vClass="pedestrian" emissionClass="Zero/default" guiShape="scooter" width="0.40" height="1.20" color="green" personCapacity="1" latAlignment="right" laneChangeModel="SL2015" jmDriveAfterYellowTime="3600.0" jmDriveAfterRedTime="200.0" jmIgnoreKeepClearTime="0.0" accel="2.0" decel="4.0" emergencyDecel="7.0" sd="0.9" tau="1.0"/> -->
</routes>
"""

BK_attrib = {"id": "0", "vClass": "bicycle", "color": "red", "maxSpeed": "5.56"}

ES_attrib = {
    "id": "0",
    "vClass": "bicycle",
    "maxSpeed": "8.9",
    "length": "1.10",
    "minGap": "1.50",
    "guiShape": "scooter",
    "width": "0.40",
    "height": "1.20",
    "color": "green",
    "accel": "2.0",
    "decel": "4.0",
    "emergencyDecel": "7.0",
}

PED_attrib = {
    "id": "0",
    "vClass": "pedestrian",
}

PED_CROSSING_WIDTH = 3.0


class VehicleContainer(defaultdict):
    """=defaultdict(lambda: defaultdict(lambda : np.array([])))"""

    def __init__(self):
        self.default_factory = lambda: defaultdict(lambda: np.array([]))
        
    def useNumpyArray(self, use_arrays):
        if use_arrays:
            self.default_factory = lambda: defaultdict(lambda: np.array([]))
        else:
            self.default_factory = lambda: defaultdict(lambda: [])


def createNet(net_xml_path, bike_lane_width=1.5, crossing_location=30.0):
    print("-> Building Network\n", end='')
    net = Net(
        Node(), Edge(numLanes=1, maxSpeed=13.89, width=bike_lane_width, allow="bicycle pedestrian")
    )

    net.addNode(Node("j1", x=0.0, y=0.0))
    net.addNode(Node("C", x=0.0, y=crossing_location))
    net.addNode(Node("j2", x=0.0, y=40.0))
    net.addNode(Node("j3", x=-10.0, y=crossing_location))
    net.addNode(Node("j4", x=10.0, y=crossing_location))

    net.connectNodes("j1", "C", edge_id="E0")
    net.connectNodes("C", "j2", edge_id="E1")

    Defaultparams = net.getDefaultEdge().misc
    Defaultparams["allow"] = "pedestrian"
    Defaultparams["width"] = PED_CROSSING_WIDTH
    Defaultparams["spreadType"] = "center"

    net.connectNodes("j3", "C", edge_id="E2")
    net.connectNodes("C", "j4", edge_id="E3")
    net.getNode("C").addCrossing(
        Crossing(
            ["E0"],
            width=PED_CROSSING_WIDTH,
            shape=f"0.0,{crossing_location} {bike_lane_width},{crossing_location}",
        )
    )

    net.build(
        net_xml_path,
        ["--default.junctions.radius", "5.0", "--default.crossing-width", "3.0"],
    )
    print("   done.\n", end='')


def createRou(rou_xml_path, objects, vTypesVariables=defaultdict(dict)):
    """create initial conditions and add variables to test against"""
    print(f"-> Building Routes {rou_xml_path}\n", end='')
    root = ET.fromstring(base_routes_xml)

    # list for sorting vehicles and person per depart time
    vehicles_list = []

    for obj in objects:
        name = obj.id
        mobile = obj.mobile
        localVars = vTypesVariables[obj.type]

        # get start postions
        start_x_pos = mobile["x"][0]
        start_y_pos = mobile["y"][0]

        # will be set by variables
        # maxSpeedReached = max(mobile['s'])
        # maxAccelReached = max(max(mobile["a"]), 0.1)
        # maxDecelReached = max(abs(min(mobile["a"])), 0.1)

        if obj.type == 2 or obj.type == 3:  # it is a bike==3 or ES==2
            
            pers = ET.Element("trip")

            # ES and bikes have very close speeds
            if obj.type == 3:
                #print(f"   veh {name} is Bike")
                vehtype = f"BK{name}"
                myveh = ET.SubElement(
                    root, "vType", attrib=dict(BK_attrib, **localVars)
                )
                # cap max speed to vType max speed to avoid crashes
                speed = min(mobile["s"][0], float(localVars.get("maxSpeed", BK_attrib.get("maxSpeed", 5.5))))
            else:
                #print(f"   veh {name} is ES")
                vehtype = f"ES{name}"
                myveh = ET.SubElement(
                    root, "vType", attrib=dict(ES_attrib, **localVars)
                )
                # cap max speed to vType max speed to avoid crashes
                speed = min(mobile["s"][0], float(localVars.get("maxSpeed", ES_attrib.get("maxSpeed", 5.5))))
            pers.set("type", vehtype)

            # pers.set('fromXY',f'{start_x_pos},{start_y_pos}')
            pers.set("departPos", str(start_y_pos))
            pers.set("departSpeed", str(speed))
            pers.set("arrivalPos", "10")
            pers.set("from", "E0")
            pers.set("to", "E1")

        elif obj.type == 1:  # it is a pedestrian==1
            pers = ET.Element("person")
            vehtype = f"PED{name}"
            pers.set("type", vehtype)

            myveh = ET.SubElement(root, "vType", attrib=dict(PED_attrib, **localVars))
            speed = min(mobile["s"][0], float(localVars.get("maxSpeed", PED_attrib.get("maxSpeed", 5.5))))

            mywalk = ET.SubElement(pers, "walk")
            # will be set by vTypes variables
            # mywalk.set('speed', str(speed))

            if start_x_pos < 0:  # going left to right
                mywalk.set(
                    "departPosLat", str(30 - start_y_pos)
                )  # positive is right side in walking direction
                mywalk.set("from", "E2")
                mywalk.set("to", "E3")
                pers.set("departPos", "0")
                mywalk.set("arrivalPos", "10")

            else:  # going right to left
                mywalk.set(
                    "departPosLat", str(start_y_pos - 30)
                )  # positive is right side in walking direction
                mywalk.set("from", "E3")
                mywalk.set("to", "E2")
                pers.set("departPos", "10")
                mywalk.set("arrivalPos", "0")
            #print(f"   veh {name} is pedestrian")
        else:
            raise RuntimeError(f"Rou.xml gen: Unknown vehicle {name} of type {obj.type}")
        # assign the same id from tracking phase
        pers.set("id", str(name))

        # assign vehicle name
        myveh.set("id", vehtype)

        # will be set by vTypes variables
        # myveh.set('maxSpeed', str(maxSpeedReached))
        # myveh.set('accel', str(maxAccelReached))
        # myveh.set('decel', str(maxDecelReached))

        # get when the person is inserted into the flow
        pers.set("depart", str(mobile["t"][0]))

        # save for sort
        vehicles_list.append(pers)

    # insert ordered by depart
    vehicles_list.sort(key=lambda e: float(e.attrib["depart"]))
    root.append(ET.Comment(text="Vehicles, persons and containers (sorted by depart)"))
    root.extend(vehicles_list)

    # write rou.xml file to scenario
    tree = ET.ElementTree(element=root)
    ET.indent(tree)
    with open(rou_xml_path, mode="wb") as out_file:
        tree.write(out_file, encoding="utf-8")
    print(f"   done building routes {rou_xml_path}\n", end='')


def loadFcd(
    fcd_file,
    element_types=["vehicle", "person"],
    attrs=["id", "x", "y", "angle", "speed"],
):
    # routes = defaultdict(list)  # vehID -> recorded edges
    # vehID -> (times, speeds, distances, accelerations, angles, xPositions, yPositions, kilometrage)

    elements_and_attr_to_get = {e: attrs for e in element_types}

    fcd_data = VehicleContainer()
    fcd_data.useNumpyArray(False) #faster for appending

    totalVehs = 0
    for timestep in parse_fast_structured(
        fcd_file, "timestep", ["time"], elements_and_attr_to_get
    ):
        for vehicle in timestep.vehicle + timestep.person:
                    
            totalVehs += 1
            vehID = int(vehicle.id)
            # edge = vehicle.lane[0:vehicle.lane.rfind('_')]
            # if len(routes[vehID]) == 0 or routes[vehID][-1] != edge:
            # routes[vehID].append(edge)
            time = parseTime(timestep.time)
            speed = float(vehicle.speed)
            prevTime = time
            prevSpeed = speed
            #prevDist = 0
            if vehID in fcd_data:
                prevTime = fcd_data[vehID]["t"][-1]
                prevSpeed = fcd_data[vehID]["s"][-1]
                #prevDist = fcd_data[vehID]["d"][-1]
            fcd_data[vehID]["t"].append(time)
            fcd_data[vehID]["s"].append(speed)
            fcd_data[vehID]["i"].append(float(vehicle.angle))
            fcd_data[vehID]["x"].append(float(vehicle.x))
            fcd_data[vehID]["y"].append(float(vehicle.y))
            if prevTime == time:
                accel = 0.0
            else:
                accel = (speed - prevSpeed) / (time - prevTime)
            fcd_data[vehID]["a"].append(accel)

            # avgSpeed = speed

            # fcd_data[vehID]['d'].append(prevDist + (time - prevTime) * avgSpeed)

    assert totalVehs > 0, "no vehicles!!"

    #toNumpyArrays
    for veh in fcd_data:
        for entry in fcd_data[veh]:
            fcd_data[veh][entry] = np.array( fcd_data[veh][entry] )
    fcd_data.useNumpyArray(True)
    
    return fcd_data
